<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>比赛回放</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            padding: 20px;
            padding-bottom: 100px; 
            padding-top: 20px;
            background-color: #f9f9f9;
        }
        h1 { text-align: center; color: #333; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        thead { position: sticky; top: 0; z-index: 10; }
        th, td { border: 1px solid #ddd; padding: 10px 12px; text-align: center; white-space: nowrap; }
        thead th { background-color: #4CAF50; color: white; font-size: 16px; }
        tbody tr:nth-child(even) { background-color: #f2f2f2; }
        .ac { background-color: #d4edda !important; color: #155724; font-weight: bold; }
        .wa { background-color: #f8d7da !important; color: #721c24; }
        .pending { background-color: #d1ecf1 !important; color: #0c5460; font-weight: bold; }
        .solved-time { color: #6c757d; font-size: 0.8em; }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #333;
            color: white;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-sizing: border-box;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.5);
            z-index: 100;
        }
        
        .scheduler-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: auto;
        }
        .scheduler-group label { font-weight: bold; font-size: 0.9em; }
        .scheduler-group input[type="datetime-local"] {
            background-color: #555; color: white; border: 1px solid #777; border-radius: 4px; padding: 5px;
        }
        .scheduler-group input:disabled { background-color: #444; color: #888; cursor: not-allowed; }
        #timer-status { font-family: 'Courier New', Courier, monospace; font-size: 0.9em; min-width: 150px; }
        /* 【样式改进】为禁用的播放控件添加更明确的视觉提示 */
        .controls button:disabled, .controls input:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

                /* 1. 进度条是唯一允许生长的元素 */
        .controls input[type="range"] {
            flex-grow: 1;
        }
        
        /* 2. 其他所有直接子元素都保持其自然宽度，并且不允许被压缩 */
        .controls > button, 
        .controls > input[type="text"], 
        .controls > span, 
        .controls > .scheduler-group {
            flex-shrink: 0;
        }

        /* 3. 定时器组不再使用 margin-left: auto */
        .scheduler-group {
            display: flex;
            align-items: center;
            gap: 10px;
            /* 移除 margin-left: auto */
        }
        
        .controls input[type="text"] {
            width: 110px;
            padding: 8px;
            font-size: 1.2em;
            background-color: #555;
            color: white;
            border: 1px solid #777;
            border-radius: 4px;
            text-align: center;
            font-family: 'Courier New', Courier, monospace;
        }
        .time-display { font-size: 1.5em; font-weight: bold; min-width: 120px; text-align: center; font-family: 'Courier New', Courier, monospace; }
        
        #frozen-banner {
            display: none; position: fixed; top: 15px; right: 10px;
            background-color: #17a2b8; color: white; padding: 10px 20px; border-radius: 5px;
            font-size: 1.2em; font-weight: bold; z-index: 50; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .admin-link {
            position: absolute; top: 20px; left: 20px; padding: 8px 15px; background-color: #6c757d;
            color: white; text-decoration: none; border-radius: 5px; font-size: 0.9em;
        }
        #unfreeze-btn { background-color: #dc3545; color: white; }
    </style>
</head>
<body>
    <h1>比赛回放</h1>
    <a href="/update" target="_blank" class="admin-link">后台控制面板</a>
    <div id="frozen-banner">榜单已封！</div>

    <table>
        <thead id="board-header"></thead>
        <tbody id="board-body"></tbody>
    </table>

    <div class="stats-container">
        <h2>题目统计</h2>
        <table class="stats-table">
            <thead id="stats-header"></thead>
            <tbody id="stats-body"></tbody>
        </table>
    </div>

    <div class="controls">
        <button id="play-pause-btn">▶</button>
        <input type="text" id="manual-time-input" placeholder="00:00:00">
        <input type="range" id="time-slider" min="0" max="18000" value="0">
        <span id="total-time-display" class="time-display">05:00:00</span>
        
        <div class="scheduler-group">
            <label for="timer-toggle">定时启动:</label>
            <input type="checkbox" id="timer-toggle" style="transform: scale(1.5);">
            <input type="datetime-local" id="start-time-input">
            <span id="timer-status"></span>
        </div>

        <button id="unfreeze-btn" style="display: none;">解榜</button>
    </div>

    <script>
        // DOM Elements
        const boardHeader = document.getElementById('board-header');
        const boardBody = document.getElementById('board-body');
        const statsHeader = document.getElementById('stats-header');
        const statsBody = document.getElementById('stats-body');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const timeSlider = document.getElementById('time-slider');
        const totalTimeDisplay = document.getElementById('total-time-display');
        const frozenBanner = document.getElementById('frozen-banner');
        const unfreezeBtn = document.getElementById('unfreeze-btn');
        const manualTimeInput = document.getElementById('manual-time-input');
        const timerToggle = document.getElementById('timer-toggle');
        const startTimeInput = document.getElementById('start-time-input');
        const timerStatus = document.getElementById('timer-status');

        // State Variables
        let problems = [];
        let totalDurationSec = 300 * 60;
        let currentSecond = 0;
        let isPlaying = false;
        let playbackSpeed = 1000;
        let playbackInterval;
        const FROZEN_BOARD_SECOND = 240 * 60;
        let isUnfrozen = false;
        let timerCheckInterval;

        // --- Functions (updateBoardForTime and dependent render functions remain unchanged) ---
        function formatTime(totalSeconds) { /* ... no changes ... */ 
            const h = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
            const m = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
            const s = String(totalSeconds % 60).padStart(2, '0');
            return `${h}:${m}:${s}`;
        }
        async function updateBoardForTime(seconds) { /* ... no changes ... */ 
            currentSecond = Math.max(0, Math.min(seconds, totalDurationSec));
            timeSlider.value = currentSecond;
            manualTimeInput.value = formatTime(currentSecond);

            let displaySeconds = currentSecond;
            if (!isUnfrozen && currentSecond >= FROZEN_BOARD_SECOND) {
                displaySeconds = FROZEN_BOARD_SECOND;
            }

            const showFrozenBanner = !isUnfrozen && currentSecond >= FROZEN_BOARD_SECOND;
            frozenBanner.style.display = showFrozenBanner ? 'block' : 'none';
            unfreezeBtn.style.display = (currentSecond === totalDurationSec) ? 'block' : 'none';

            try {
                const response = await fetch(`/api/board_at_time/${displaySeconds}`);
                const data = await response.json();
                renderBoard(data.board, currentSecond);
                renderStatistics(data.statistics);
            } catch (error) {
                console.error("更新榜单失败:", error);
            }
        }
        function renderBoard(boardData, realSeconds) { /* ... no changes ... */ 
            let bodyHTML = '';
            boardData.forEach(team => {
                bodyHTML += `<tr><td>${team.rank}</td><td title="${team.team}" style="text-align: left; max-width: 250px; overflow: hidden; text-overflow: ellipsis;">${team.team}</td><td>${team.solved}</td><td>${team.penalty}</td>`;
                problems.forEach(pid => {
                    const probInfo = team.status[pid];
                    const shouldShowPending = 
                        !isUnfrozen && 
                        realSeconds > FROZEN_BOARD_SECOND && 
                        probInfo.final_effective_last_sub_time > FROZEN_BOARD_SECOND &&
                        probInfo.final_effective_last_sub_time <= realSeconds;

                    if (shouldShowPending) {
                        const attempts_before_pending = probInfo.final_total_attempts > 0 ? probInfo.final_total_attempts - 1 : 0;
                        const content = attempts_before_pending > 0 ? `? ${attempts_before_pending}` : '?';
                        bodyHTML += `<td class="pending">${content}</td>`;
                    } else if (probInfo.display.includes('+')) {
                        bodyHTML += `<td class="ac">${probInfo.display}<br><small class="solved-time">${probInfo.solved_time}</small></td>`;
                    } else if (probInfo.display.includes('-')) {
                        bodyHTML += `<td class="wa">${probInfo.display}</td>`;
                    } else {
                        bodyHTML += `<td></td>`;
                    }
                });
                bodyHTML += '</tr>';
            });
            boardBody.innerHTML = bodyHTML;
        }
        function renderStatistics(stats) { /* ... no changes ... */ 
             if (stats && Object.keys(stats).length > 0) {
                let statsHeaderHTML = '<tr><th>Statistic</th>';
                problems.forEach(pid => statsHeaderHTML += `<th>${pid}</th>`);
                statsHeaderHTML += '</tr>';
                statsHeader.innerHTML = statsHeaderHTML;

                let statsBodyHTML = '';
                const rowOrder = ['Submitted', 'Accepted', 'First Solved'];
                rowOrder.forEach(rowName => {
                    if (stats[rowName]) {
                        statsBodyHTML += `<tr><td class="stat-name">${rowName}</td>`;
                        problems.forEach(pid => {
                            statsBodyHTML += `<td>${stats[rowName][pid] || ''}</td>`;
                        });
                        statsBodyHTML += '</tr>';
                    }
                });
                statsBody.innerHTML = statsBodyHTML;
            }
        }
        function togglePlayback() { /* ... no changes ... */ 
            isPlaying = !isPlaying;
            if (isPlaying) {
                if (currentSecond >= totalDurationSec) {
                    currentSecond = 0;
                }
                playPauseBtn.textContent = '❚❚';
                playbackInterval = setInterval(() => {
                    if (currentSecond < totalDurationSec) {
                        updateBoardForTime(currentSecond + 1);
                    } else {
                        togglePlayback();
                    }
                }, playbackSpeed);
            } else {
                playPauseBtn.textContent = '▶';
                clearInterval(playbackInterval);
            }
        }
        function unfreezeBoard() { /* ... no changes ... */ 
            isUnfrozen = true;
            unfreezeBtn.style.display = 'none';
            updateBoardForTime(totalDurationSec);
        }
        function parseTimeInput(timeStr) { /* ... no changes ... */ 
            const parts = timeStr.split(':').map(Number);
            let seconds = 0;
            if (parts.length === 3) {
                seconds = parts[0] * 3600 + parts[1] * 60 + parts[2];
            } else if (parts.length === 2) {
                seconds = parts[0] * 60 + parts[1];
            } else if (parts.length === 1) {
                seconds = parts[0];
            }
            return isNaN(seconds) ? -1 : seconds;
        }

        // --- 【逻辑修正】核心控制函数 ---
        function setControlsForTimerMode(isTimerActive) {
            // 播放控件与定时器模式状态相反
            playPauseBtn.disabled = isTimerActive;
            timeSlider.disabled = isTimerActive;
            manualTimeInput.disabled = isTimerActive;
            unfreezeBtn.disabled = isTimerActive;

        }

        function checkTimer() {
            const startTimeStr = localStorage.getItem('scheduledStartTime');
            if (!startTimeStr) {
                timerStatus.textContent = '未设置';
                return;
            }
            
            const startTime = new Date(startTimeStr);
            const now = new Date();
            const diffSeconds = Math.floor((now - startTime) / 1000);

            if (diffSeconds >= 0) { // 时间到或已过
                clearInterval(timerCheckInterval);
                timerStatus.textContent = '已启动！';

                // 【逻辑修正】保持播放控件禁用，这是关键！
                // setControlsForTimerMode(true); 

                // 计算进度并开始播放
                updateBoardForTime(diffSeconds);
                if (diffSeconds < totalDurationSec && !isPlaying) {
                    togglePlayback();
                }

            } else { // 还没到时间
                timerStatus.textContent = `倒计时: ${formatTime(Math.abs(diffSeconds))}`;
            }
        }

        // --- Initialization ---
        async function initialize() {
            try {
                const response = await fetch('/api/initial_data');
                const data = await response.json();
                problems = data.problems;
                totalDurationSec = data.total_duration_sec;
                timeSlider.max = totalDurationSec;
                totalTimeDisplay.textContent = formatTime(totalDurationSec);

                let headerHTML = '<tr><th>排名</th><th>队伍</th><th>解题数</th><th>罚时</th>';
                problems.forEach(pid => headerHTML += `<th>${pid}</th>`);
                headerHTML += '</tr>';
                boardHeader.innerHTML = headerHTML;

                await updateBoardForTime(0);

                // 【逻辑修正】初始化时根据存储状态设置所有控件
                const timerEnabled = localStorage.getItem('timerEnabled') === 'true';
                timerToggle.checked = timerEnabled;
                setControlsForTimerMode(timerEnabled); // 根据是否为定时模式，设置所有控件的初始状态

                const savedTime = localStorage.getItem('scheduledStartTime');
                if (savedTime) {
                    startTimeInput.value = savedTime;
                }
                
                if (timerEnabled) {
                    timerCheckInterval = setInterval(checkTimer, 1000);
                    checkTimer(); // 立即执行一次，处理页面加载时就已过期的定时器
                }

            } catch (error) {
                console.error("初始化页面失败:", error);
            }
        }

        // --- Event Listeners ---
        playPauseBtn.addEventListener('click', togglePlayback);
        timeSlider.addEventListener('input', (e) => {
            if (isPlaying) togglePlayback();
            updateBoardForTime(parseInt(e.target.value));
        });
        unfreezeBtn.addEventListener('click', unfreezeBoard);
        
        manualTimeInput.addEventListener('change', (e) => {
            const seconds = parseTimeInput(e.target.value);
            if (seconds >= 0 && seconds <= totalDurationSec) {
                if (isPlaying) togglePlayback();
                updateBoardForTime(seconds);
            } else {
                alert('输入的时间格式无效或超出范围！');
                e.target.value = formatTime(currentSecond);
            }
        });

        // 【逻辑修正】定时器开关事件处理
        timerToggle.addEventListener('change', () => {
            const enabled = timerToggle.checked;
            localStorage.setItem('timerEnabled', enabled);
            setControlsForTimerMode(enabled); // 切换时立即更新所有相关控件的状态

            if (enabled) {
                // 如果是手动播放中，先暂停
                if (isPlaying) togglePlayback();
                
                // 自动设置一个默认启动时间
                if (!startTimeInput.value) {
                    const now = new Date();
                    now.setMinutes(now.getMinutes() + 1);
                    now.setSeconds(0);
                    const localISOString = new Date(now.getTime() - (now.getTimezoneOffset() * 60000)).toISOString().slice(0, 16);
                    startTimeInput.value = localISOString;
                }
                localStorage.setItem('scheduledStartTime', startTimeInput.value);
                
                timerCheckInterval = setInterval(checkTimer, 1000);
                checkTimer();
            } else {
                // 关闭定时模式
                clearInterval(timerCheckInterval);
                timerStatus.textContent = '';
                localStorage.removeItem('timerEnabled');
                localStorage.removeItem('scheduledStartTime');

                // 【逻辑修正】如果之前是自动播放，现在要停下来
                if (isPlaying) togglePlayback();
            }
        });
        
        startTimeInput.addEventListener('change', () => {
            localStorage.setItem('scheduledStartTime', startTimeInput.value);
            if (timerToggle.checked) {
                // 重置并重新开始倒计时
                clearInterval(timerCheckInterval);
                timerCheckInterval = setInterval(checkTimer, 1000);
                checkTimer(); // 立即更新倒计时显示
            }
        });

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>